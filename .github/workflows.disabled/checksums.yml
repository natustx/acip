# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
# -----------------------------------------------------------------------------
# ACIP Checksums Workflow
# -----------------------------------------------------------------------------
# Generates SHA256 checksums and manifest for ACIP files, signs with Sigstore
# cosign (keyless), and commits results to the repository.
#
# Security considerations:
# - All actions pinned to full SHA for supply chain security
# - Minimal permissions following principle of least privilege
# - Stale run detection prevents race conditions
# - Keyless signing via Sigstore for transparent provenance
# -----------------------------------------------------------------------------

name: Generate ACIP Checksums

'on':
  push:
    branches: [main]
    paths:
      - 'ACIP_*.md'
      - 'integrations/**'
      - 'README.md'
      - 'RECOMMENDED_VERSION'
      - '.github/workflows/checksums.yml'
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regeneration even if files unchanged'
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: acip-checksums-${{ github.ref }}
  cancel-in-progress: true

env:
  # Centralized action versions for easier updates
  COSIGN_RELEASE: 'v2.4.3'

jobs:
  generate-checksums:
    name: Generate Checksums & Manifest
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: read
    outputs:
      checksums_changed: ${{ steps.generate.outputs.checksums_changed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.sha }}

      - name: Generate checksums and manifest
        id: generate
        shell: bash
        run: |
          set -euo pipefail

          # Create checksums directory
          mkdir -p .checksums
          rm -f .checksums/*.sha256 .checksums/SHA256SUMS .checksums/manifest.json 2>/dev/null || true

          echo "::group::Generating checksums for ACIP files"

          # Get commit timestamp + commit (stable across reruns for the same commit)
          COMMIT=$(git rev-parse HEAD)
          COMMIT_UNIX_TS=$(git show -s --format=%ct "$COMMIT")
          TIMESTAMP=$(date -u -d "@$COMMIT_UNIX_TS" +"%Y-%m-%dT%H:%M:%SZ")

          echo "Commit: $COMMIT"
          echo "Timestamp: $TIMESTAMP"

          # Resolve latest and recommended versions.
          # - latest: highest ACIP_v_* version found
          # - recommended: RECOMMENDED_VERSION file if present, else latest
          LATEST_VERSION=$(ls ACIP_v_*.md 2>/dev/null | sed -E 's/ACIP_v_([0-9.]+)_.*/\1/' | sort -V | tail -1)
          RECOMMENDED_VERSION=$(tr -d '[:space:]' < RECOMMENDED_VERSION 2>/dev/null || true)
          if [ -z "${RECOMMENDED_VERSION:-}" ]; then
            RECOMMENDED_VERSION="$LATEST_VERSION"
          fi

          echo "Latest version: $LATEST_VERSION"
          echo "Recommended version: $RECOMMENDED_VERSION"

          # Start building the versions array
          VERSIONS_JSON="["
          FIRST=true

          # Process main ACIP version files
          for file in ACIP_v_*.md; do
            if [ -f "$file" ]; then
              echo "Processing: $file"

              # Extract version from filename (e.g., ACIP_v_1.3_Full_Text.md -> 1.3)
              VERSION=$(echo "$file" | sed -E 's/ACIP_v_([0-9.]+)_.*/\1/')

              # Generate SHA256 checksum
              CHECKSUM=$(sha256sum "$file" | cut -d' ' -f1)

              # Get file size (Linux stat syntax)
              SIZE=$(stat -c%s "$file")

              # Get line count
              LINES=$(wc -l < "$file" | tr -d ' ')

              # Write individual checksum file
              echo "$CHECKSUM  $file" > ".checksums/${file%.md}.sha256"

              # Add to versions array
              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                VERSIONS_JSON="$VERSIONS_JSON,"
              fi

              VERSIONS_JSON="$VERSIONS_JSON
                {
                  \"version\": \"$VERSION\",
                  \"file\": \"$file\",
                  \"sha256\": \"$CHECKSUM\",
                  \"size_bytes\": $SIZE,
                  \"lines\": $LINES,
                  \"tokens\": null,
                  \"raw_url\": \"https://raw.githubusercontent.com/${{ github.repository }}/$COMMIT/$file\"
                }"
            fi
          done

          VERSIONS_JSON="$VERSIONS_JSON
            ]"

          echo "::endgroup::"
          echo "::group::Processing integrations"

          # Build integrations array
          INTEGRATIONS_JSON="["
          FIRST_INT=true

          # Process integration files (unique; include md + sh)
          if [ -d integrations ]; then
            while IFS= read -r intfile; do
              echo "Processing integration: $intfile"

              # Extract integration name from path
              INT_NAME=$(echo "$intfile" | cut -d'/' -f2)

              # Generate SHA256 checksum
              INT_CHECKSUM=$(sha256sum "$intfile" | cut -d' ' -f1)

              # Get file size (Linux stat syntax)
              INT_SIZE=$(stat -c%s "$intfile")

              # Get line count
              INT_LINES=$(wc -l < "$intfile" | tr -d ' ')

              # Write individual checksum file
              SAFE_NAME=$(echo "$intfile" | tr '/' '_')
              echo "$INT_CHECKSUM  $intfile" > ".checksums/${SAFE_NAME%.md}.sha256"

              # Add to integrations array
              if [ "$FIRST_INT" = true ]; then
                FIRST_INT=false
              else
                INTEGRATIONS_JSON="$INTEGRATIONS_JSON,"
              fi

              INTEGRATIONS_JSON="$INTEGRATIONS_JSON
                {
                  \"integration\": \"$INT_NAME\",
                  \"file\": \"$intfile\",
                  \"sha256\": \"$INT_CHECKSUM\",
                  \"size_bytes\": $INT_SIZE,
                  \"lines\": $INT_LINES,
                  \"tokens\": null,
                  \"raw_url\": \"https://raw.githubusercontent.com/${{ github.repository }}/$COMMIT/$intfile\"
                }"
            done < <(find integrations -type f \( -name '*.md' -o -name '*.sh' \) -print | LC_ALL=C sort -u)
          fi

          INTEGRATIONS_JSON="$INTEGRATIONS_JSON
            ]"

          echo "::endgroup::"
          echo "::group::Creating manifest"

          # Create final manifest using jq for proper JSON formatting
          cat > .checksums/manifest.json << EOF
          {
            "schema_version": "1.2",
            "project": "ACIP",
            "description": "Advanced Cognitive Inoculation Prompt - Checksums and Metadata",
            "repository": "https://github.com/${{ github.repository }}",
            "generated_at": "$TIMESTAMP",
            "commit": "$COMMIT",
            "recommended_version": "$RECOMMENDED_VERSION",
            "latest_version": "$LATEST_VERSION",
            "tokenizer": null,
            "versions": $VERSIONS_JSON,
            "integrations": $INTEGRATIONS_JSON,
            "verification": {
              "instructions": "To verify: sha256sum -c <version>.sha256",
              "example": "curl -fsSL https://raw.githubusercontent.com/${{ github.repository }}/main/.checksums/ACIP_v_1.3_Full_Text.sha256 | sha256sum -c"
            }
          }
          EOF

          # Pretty print the manifest
          echo "Generated manifest:"
          cat .checksums/manifest.json

          # Also create a combined checksums file
          cat .checksums/*.sha256 > .checksums/SHA256SUMS 2>/dev/null || true

          echo "::endgroup::"

          # Check if checksums actually changed
          if git diff --quiet -- .checksums/ 2>/dev/null; then
            echo "checksums_changed=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No changes to checksums detected"
          else
            echo "checksums_changed=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Checksums have been updated"
          fi

      - name: Upload generated checksums (unsigned)
        uses: actions/upload-artifact@v4
        with:
          name: acip-checksums
          path: .checksums/
          retention-days: 7
          if-no-files-found: error
          include-hidden-files: true

  sign-and-commit:
    name: Sign & Commit Checksums
    if: github.ref == 'refs/heads/main'
    needs: generate-checksums
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: write
      id-token: write  # Required for keyless signing with Sigstore
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.sha }}

      - name: Guard against stale runs
        id: guard
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main --quiet
          REMOTE_MAIN="$(git rev-parse origin/main)"
          if [ "$REMOTE_MAIN" != "${{ github.sha }}" ]; then
            echo "::warning::main advanced to $REMOTE_MAIN; skipping checksums commit for stale sha ${{ github.sha }}"
            echo "proceed=false" >> "$GITHUB_OUTPUT"
          else
            echo "proceed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare checksums directory
        if: steps.guard.outputs.proceed == 'true'
        run: rm -rf .checksums

      - name: Download generated checksums
        if: steps.guard.outputs.proceed == 'true'
        uses: actions/download-artifact@v4
        with:
          name: acip-checksums
          path: .checksums

      - name: Verify artifact integrity
        if: steps.guard.outputs.proceed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Verify the manifest exists and is valid JSON
          if [ ! -f .checksums/manifest.json ]; then
            echo "::error::manifest.json not found in downloaded artifact"
            exit 1
          fi
          # Basic JSON validation
          if ! python3 -c "import json; json.load(open('.checksums/manifest.json'))"; then
            echo "::error::manifest.json is not valid JSON"
            exit 1
          fi
          echo "::notice::Artifact integrity verified"

      - name: Install cosign
        if: steps.guard.outputs.proceed == 'true'
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.4.3'

      - name: Verify cosign installation
        if: steps.guard.outputs.proceed == 'true'
        run: |
          cosign version
          echo "::notice::Cosign installed successfully"

      - name: Sign manifest (keyless via Sigstore)
        if: steps.guard.outputs.proceed == 'true'
        shell: bash
        run: |
          set -euo pipefail

          # Check if signature already exists and manifest is unchanged
          if git diff --quiet -- .checksums/manifest.json 2>/dev/null && \
             [ -f .checksums/manifest.json.sig ] && \
             [ -f .checksums/manifest.json.pem ] && \
             [ -f .checksums/manifest.json.bundle ]; then
            echo "::notice::Manifest unchanged and signature already present; skipping signing"
            exit 0
          fi

          echo "::group::Signing manifest with cosign"
          cosign sign-blob --yes \
            --bundle .checksums/manifest.json.bundle \
            --output-signature .checksums/manifest.json.sig \
            --output-certificate .checksums/manifest.json.pem \
            .checksums/manifest.json
          echo "::endgroup::"

          # Normalize certificate to PEM for easier manual verification
          if ! grep -q "BEGIN CERTIFICATE" .checksums/manifest.json.pem 2>/dev/null; then
            if base64 -d .checksums/manifest.json.pem > .checksums/manifest.json.pem.decoded 2>/dev/null; then
              if grep -q "BEGIN CERTIFICATE" .checksums/manifest.json.pem.decoded; then
                mv .checksums/manifest.json.pem.decoded .checksums/manifest.json.pem
              else
                rm -f .checksums/manifest.json.pem.decoded
              fi
            fi
          fi

          echo "::notice::Manifest signed successfully"

      - name: Commit checksums
        if: steps.guard.outputs.proceed == 'true'
        shell: bash
        run: |
          set -euo pipefail

          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add .checksums/

          if git diff --staged --quiet; then
            echo "::notice::No changes to checksums - nothing to commit"
            exit 0
          fi

          # Create commit with detailed message
          git commit -m "chore: update ACIP checksums [skip ci]" \
            -m "Automated checksum regeneration triggered by file changes." \
            -m "Signed-off-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

          # Push with retry logic for transient failures
          for attempt in 1 2 3; do
            if git push origin HEAD:main; then
              echo "::notice::Checksums committed and pushed successfully"
              exit 0
            fi
            echo "::warning::Push attempt $attempt failed, retrying..."
            sleep $((attempt * 2))
            git fetch origin main --quiet
            if [ "$(git rev-parse origin/main)" != "$(git rev-parse HEAD~1)" ]; then
              echo "::warning::main has advanced during push attempts; aborting to prevent conflicts"
              exit 0
            fi
          done

          echo "::warning::Push failed after 3 attempts (likely due to concurrent updates). Skipping."
          exit 0

      - name: Upload signed checksums
        if: steps.guard.outputs.proceed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: acip-checksums-signed
          path: .checksums/
          retention-days: 90
          if-no-files-found: error
          include-hidden-files: true
